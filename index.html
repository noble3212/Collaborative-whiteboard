<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Realtime Collaborative Whiteboard</title>
<style>
html, body {height:100%;margin:0;padding:0;background:#fafafa;font-family:sans-serif;overflow:hidden;}
#toolbar {display:flex;justify-content:center;align-items:center;gap:15px;background:#fff;padding:10px;border-bottom:2px solid #000;position:fixed;top:0;left:0;width:100%;z-index:10;}
#canvas {position:absolute;top:60px;left:0;width:100%;height:calc(100% - 60px);background:#fff;cursor:crosshair;touch-action:none;}
</style>
</head>
<body>
<div id="toolbar">
<strong>Realtime Whiteboard</strong>
<label>Color: <input type="color" id="colorPicker" value="#000000" /></label>
<label>Brush: <input type="range" id="sizePicker" min="1" max="20" value="4" /></label>
<button id="clearBtn">Clear</button>
</div>

<canvas id="canvas"></canvas>
<script src="https://cdn.ably.io/lib/ably.min-1.2.4.js"></script> 
<script>
const ABLY_API_KEY = "9DoYcA.L_yHCw:to2-Air7MUk4uKZoAcm1RAUpGiNlAkqwpJiLLKiRihU";
const ably = new Ably.Realtime({ key: ABLY_API_KEY });

// Using separate channels for better management of history/rewind
// The 'stroke' channel needs sequencing for order and rewind for missed strokes
const strokeChannel = ably.channels.get("whiteboard:strokes", { params: { rewind: "100", sequenced: "true" } }); 
// The 'clear' channel only needs to rewind the last message to catch new clients up
const clearChannel = ably.channels.get("whiteboard:clear", { params: { rewind: "1" } }); 


const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
ctx.lineCap = "round";
ctx.lineJoin = "round";

function resizeCanvas(){
Â  Â  canvas.width = window.innerWidth;
Â  Â  // Calculate height dynamically from the toolbar height for accurate canvas sizing
Â  Â  canvas.height = window.innerHeight - document.getElementById("toolbar").offsetHeight; 
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

let drawing = false;
let lastX=0, lastY=0;
let color = document.getElementById("colorPicker").value;
let size = document.getElementById("sizePicker").value;

function drawLine(x1,y1,x2,y2,color,size){
Â  Â  ctx.strokeStyle=color;
Â  Â  ctx.lineWidth=size;
Â  Â  ctx.beginPath();
Â  Â  ctx.moveTo(x1,y1);
Â  Â  ctx.lineTo(x2,y2);
Â  Â  ctx.stroke();
}

// ðŸš€ FIXED: Removed the message-spamming interpolation loop.
// We send a single message for the segment drawn in the move event.
function sendStroke(x1,y1,x2,y2){
Â  Â  // Publish normalized coordinates (0 to 1) for screen size independence
Â  Â  strokeChannel.publish("stroke",{
Â  Â  Â  Â  x1: x1 / canvas.width,
Â  Â  Â  Â  y1: y1 / canvas.height,
Â  Â  Â  Â  x2: x2 / canvas.width,
Â  Â  Â  Â  y2: y2 / canvas.height,
Â  Â  Â  Â  color,
Â  Â  Â  Â  size
Â  Â  });
}

// --- Mouse ---
canvas.addEventListener("mousedown",(e)=>{drawing=true;[lastX,lastY]=[e.offsetX,e.offsetY];});
canvas.addEventListener("mousemove",(e)=>{
Â  Â  if(!drawing) return;
Â  Â  const [x,y]=[e.offsetX,e.offsetY];
Â  Â  drawLine(lastX,lastY,x,y,color,size);
Â  Â  sendStroke(lastX,lastY,x,y);
Â  Â  [lastX,lastY]=[x,y];
});
canvas.addEventListener("mouseup",()=>drawing=false);
canvas.addEventListener("mouseleave",()=>drawing=false);

// --- Touch ---
canvas.addEventListener("touchstart",(e)=>{
Â  Â  e.preventDefault();
Â  Â  const rect=canvas.getBoundingClientRect();
Â  Â  const touch=e.touches[0];
Â  Â  drawing=true;
Â  Â  lastX = touch.clientX - rect.left;
Â  Â  lastY = touch.clientY - rect.top;
});
canvas.addEventListener("touchmove",(e)=>{
Â  Â  e.preventDefault();
Â  Â  if(!drawing) return;
Â  Â  const rect=canvas.getBoundingClientRect();
Â  Â  const touch=e.touches[0];
Â  Â  const x = touch.clientX - rect.left;
Â  Â  const y = touch.clientY - rect.top;
Â  Â  drawLine(lastX,lastY,x,y,color,size);
Â  Â  sendStroke(lastX,lastY,x,y);
Â  Â  [lastX,lastY]=[x,y];
});
canvas.addEventListener("touchend",()=>drawing=false);

// --- Receive Strokes ---
strokeChannel.subscribe("stroke",(msg)=>{
Â  Â  const {x1,y1,x2,y2,color,size}=msg.data;
Â  Â  // Denormalize coordinates using current canvas size
Â  Â  drawLine(x1*canvas.width,y1*canvas.height,x2*canvas.width,y2*canvas.height,color,size);
});

// --- Toolbar and Clear ---
document.getElementById("colorPicker").addEventListener("change",(e)=>color=e.target.value);
document.getElementById("sizePicker").addEventListener("input",(e)=>size=e.target.value);

document.getElementById("clearBtn").addEventListener("click",()=>{
Â  Â  // 1. Clear local canvas
Â  Â  ctx.clearRect(0,0,canvas.width,canvas.height); 
Â  Â  // 2. Publish to dedicated clear channel
Â  Â  clearChannel.publish("clear",{});
});

// ðŸš€ FIXED: Subscribed to the dedicated clear channel with rewind
clearChannel.subscribe("clear",()=>ctx.clearRect(0,0,canvas.width,canvas.height));
</script>
</body>
</html>
