<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Realtime Whiteboard (Ably)</title>
<style>
html,body{height:100%;margin:0;padding:0;background:#fafafa;font-family:sans-serif;overflow:hidden;}
#toolbar{display:flex;justify-content:center;align-items:center;gap:15px;background:#fff;padding:10px;border-bottom:2px solid #000;position:fixed;top:0;left:0;width:100%;z-index:10;}
#canvas{position:absolute;top:60px;left:0;width:100%;height:calc(100% - 60px);background:#fff;cursor:crosshair;touch-action:none;}
</style>
</head>
<body>
<div id="toolbar">
<strong>Realtime Whiteboard</strong>
<label>Color: <input type="color" id="colorPicker" value="#000000"/></label>
<label>Brush: <input type="range" id="sizePicker" min="1" max="20" value="4"/></label>
<button id="clearBtn">Clear</button>
</div>
<canvas id="canvas"></canvas>
<script src="https://cdn.ably.io/lib/ably.min-1.2.4.js"></script>
<script>
const ABLY_API_KEY = "9DoYcA.L_yHCw:to2-Air7MUk4uKZoAcm1RAUpGiNlAkqwpJiLLKiRihU";
const ably = new Ably.Realtime({ key: ABLY_API_KEY });

// --- FIX 1: Connection Status Monitoring ---
// This is helpful for diagnosing brief disconnections
ably.connection.on("disconnected", () => {
    console.warn("Ably: Connection Disconnected. Reconnecting...");
    // You could update a status indicator here
});
ably.connection.on("connected", () => {
    console.log("Ably: Connection Established.");
    // You could hide a status indicator here
});
ably.connection.on("failed", (error) => {
    console.error("Ably: Connection Failed!", error);
});


// --- FIX 2: Sequenced Channel ---
// Adding 'sequenced: "true"' ensures Ably delivers messages in the correct order, 
// preventing strokes from jumping or fading due to out-of-order delivery.
const channel = ably.channels.get("whiteboard", { params: { rewind: "100", sequenced: "true" } }); 


const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
ctx.lineCap="round"; ctx.lineJoin="round";

function resizeCanvas(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight-60; }
window.addEventListener("resize",resizeCanvas); resizeCanvas();

let drawing=false, lastX=0, lastY=0;
let color=document.getElementById("colorPicker").value;
let size=document.getElementById("sizePicker").value;

// Draw a line
function drawLine(x1,y1,x2,y2,color,size){
  ctx.strokeStyle=color; ctx.lineWidth=size; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
}

// Mouse
canvas.addEventListener("mousedown",(e)=>{ 
  drawing=true; 
  lastX=e.offsetX; 
  lastY=e.offsetY; 
});

canvas.addEventListener("mousemove",(e)=>{
  if(!drawing) return;

  // Draw the segment locally
  drawLine(lastX,lastY,e.offsetX,e.offsetY,color,size);

  // Publish the single segment over Ably (Fix for excessive messages from previous step)
  channel.publish("stroke",{
    x1: lastX,
    y1: lastY,
    x2: e.offsetX,
    y2: e.offsetY,
    color,
    size
  });

  lastX=e.offsetX; 
  lastY=e.offsetY;
});

canvas.addEventListener("mouseup",()=>drawing=false);
canvas.addEventListener("mouseleave",()=>drawing=false);


// Touch
canvas.addEventListener("touchstart",(e)=>{
  e.preventDefault(); 
  const rect=canvas.getBoundingClientRect();
  const touch=e.touches[0];
  drawing=true; 
  lastX=touch.clientX-rect.left; 
  lastY=touch.clientY-rect.top;
});

canvas.addEventListener("touchmove",(e)=>{
  e.preventDefault(); 
  if(!drawing) return;

  const rect=canvas.getBoundingClientRect();
  const touch=e.touches[0];
  const currentX = touch.clientX-rect.left;
  const currentY = touch.clientY-rect.top;

  // Draw the segment locally
  drawLine(lastX,lastY,currentX,currentY,color,size);

  // Publish the single segment over Ably (Fix for excessive messages from previous step)
  channel.publish("stroke",{
    x1: lastX,
    y1: lastY,
    x2: currentX,
    y2: currentY,
    color,
    size
  });
  
  lastX=currentX; 
  lastY=currentY;
});

canvas.addEventListener("touchend",()=>drawing=false);


// Subscription
channel.subscribe("stroke",(msg)=>{
  const {x1,y1,x2,y2,color,size}=msg.data;
  drawLine(x1,y1,x2,y2,color,size);
});

// Toolbar
document.getElementById("colorPicker").addEventListener("change",e=>color=e.target.value);
document.getElementById("sizePicker").addEventListener("input",e=>size=e.target.value);

document.getElementById("clearBtn").addEventListener("click",()=>{
  ctx.clearRect(0,0,canvas.width,canvas.height);
  channel.publish("clear",{});
});
channel.subscribe("clear",()=>ctx.clearRect(0,0,canvas.width,canvas.height));
</script>
</body>
</html>

